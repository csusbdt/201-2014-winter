---
layout: default
---

<h1>Lab 8: Sorting</h1>

<h2>Learning Objectives</h2>

<ul>
<li>Learn how to develop algorithms that solve computing problems.</li>
<li>Learn about sorting algorithms.</li>
<li>Learn about time complexity.</li>
</ul>

<h2>Assignment Folder</h2>

<p>
Create folder <em>~/201/lab_8</em> to contain the files
you create for this lab.
Follow the same file naming convention
from earlier assignments.
Remember to add, commit and push your source code files after completing each exercise.
</p>

<h2>Exercise 1: Sorting (10 points)</h2>

<pre>
void mysort(vector&lt;int> &amp; v);
</pre>

<p>
Write a function called <code>mysort</code> 
that rearranges elements of a vector <code>v</code> 
so that they form an increasing sequence of values. 
Allow for different vector positions to contain the same value.
</p>

<p>
Develop your own sorting algorithm;
do not use a predefined sort routine from the standard library.
</p>

<p>
Implement a simple sorting algorithm rather than an efficient algorithm.
</p>

<p>
Write code that thoroughly tests your function. 
Express your tests using assertions.
</p>

<h2>Exercise 2: Running time of sort (10 points)</h2>

<p>
There are a wide variety of sorting algorithms that have been discovered.
These algorithms can be divided into 2 types
based on their average case running times to sort <em>n</em> values:
ones proportional to <em>n<sup>2</sup></em> 
and ones proportional to <em>n * log(n)</em>. 
Simple sorting algorithms have running times proportional to <em>n<sup>2</sup></em>.
Sorting algorithms that have a running times proportional to <em>n * log(n)</em> are more complex.
In the previous exercise, you should have come up with a simple sorting algorithm
with running time proportional to <em>n<sup>2</sup></em>.
</p>

<p class="callout">
Theoretical analysis of the running time of algorithms 
is referred to as <em>time complexity analysis</em>.
</p>

<p>
All sorting algorithms basically rely on a loop 
nested within another loop (or can be rewritten into this form).
Consider the following nested loop.
</p>

<pre>
// Loop A
for (int i = 0; i &lt; n; ++i) {
  for (int j = 0; j &lt; n; ++i) {
    // core logic
  }
}
</pre>

<p>
The outer loop runs <em>n</em> times.
For each execution of the outer loop,
the inner loop runs <em>n</em> times.
So, the total number of times the core logic executes is 
<em>n<sup>2</sup></em>.
This places Loop A in the category of an <em>n<sup>2</sup></em> running time algorithm,
which is also referred to as a <em>quadratic time algorithm</em>.
</p>

<p>
Now consider the following loop.
</p>

<pre>
// Loop B
for (int i = 0; i &lt; n; ++i) {
  for (int j = i; j &lt; n; ++i) {
    // core logic
  }
}
</pre>

<p>
The outer loop runs <em>n</em> times,
where <em>i</em> progressively takes on values from 1 to <em>n</em>.
For the <em>i<sup>th</sup></em> iteration of the outer loop,
the inner loop runs <em>n - i</em> times.
So, the total number of times the core logic executes is 
<em>(n - 0) + (n - 1) + ... + 2 + 1</em>,
which equals <em>(n<sup>2</sup> - n) / 2</em>.
</p>

<p>
For <em>n > 2</em>, we have the following.
</p>

<blockquote><em>
  1/4 &middot; n<sup>2</sup> &lt; (n<sup>2</sup> - n) / 2 &lt; 1/2 &middot; n<sup>2</sup>
</em></blockquote>

<p>
The first inequality can be demonstrated by the following.
</p>

<blockquote><em>
  1/4 &middot; n<sup>2</sup> = <br>
  (n<sup>2</sup> / 2) / 2 = <br>
  (n<sup>2</sup> - n<sup>2</sup> / 2) / 2 &lt; <br>
  (n<sup>2</sup> - n) / 2
</em></blockquote>

<p>
The second inequality can be demonstrated by the following.
</p>

<blockquote><em>
  (n<sup>2</sup> - n) / 2 = <br>
  1/2 &middot; n<sup>2</sup> - 1/2 &middot; n &lt; <br>
  1/2 &middot; n<sup>2</sup> 
</em></blockquote>

<p>
From this, you can see that the running time of Loop B is bounded below
by a constant multiple of <em>n<sup>2</sup></em> and
similarly bounded above by a constant multiple of <em>n<sup>2</sup></em>
for <em>n > 2</em>.
This property places Loop B in the category of an <em>n<sup>2</sup></em> running time algorithm.
Loops A and B are both considered to have <em>n<sup>2</sup></em> running times
even though loop A runs more times than loop B.
</p>

<p>
Your sorting algorithm probably has a structure that resembles Loop B.
In this exercise, you will verify that your sorting algorthim
runs in quadratic time.
</p>

<p>
Create file <em>ex2.cpp</em> that includes your sort function <code>mysort</code>
and a main function that creates vectors of various sizes and passes them into
<code>mysort</code>.
Add code to <code>mysort</code> to count the number of times
the inner loop is executed.
This count may become too large to fit into an int,
so declare this variable as type <code>long</code> as follows.
</p>

<pre>
long innerLoopCount = 0;
</pre>

<p class="callout">
In C++ programs, the largest possible value for an <code>int</code> is 
stored in a predefined variable named <code>INT_MAX</code>,
which is a little more than 2 billion.
</p>

<p>
We want to analyze how your sorting algorithm works for the average case,
where all possible vectors of size <em>n</em> are equally likely.
To ensure that your test vectors represent average case problems,
fill your test vectors with 
integers that are generated from the <code>rand</code> function.
</p>

<p>
Produce a scatter plot that shows the relationship between vector size
and the number of times the inner loop executes.
Place vector size on the X-axis and loop executions on the Y-axis. 
The points in your scatter plot should 
approximate a quadric curve.
</p>

<p>
Submit an image of your scatter plot with your source code.
</p>

<h2>Exercise 3: Comparison (10 points)</h2>

<p>
For this exercise, create 2 programs defined in files <em>ex3slow.cpp</em>
and <em>ex3fast.cpp</em>.
</p>

<p>
In <em>ex3slow.cpp</em>,
generate a random vector of size 100,000
and pass it to your sorting algorithm.
Run the program and observe that it never ends.
Press <em>CTRL C</em> to terminate the process.
</p>

<p>
In the <em>ex3fast.cpp</em>,
generate a random vector of size 100,000
and pass it to the sort routine that is part of the C++ standard library.
The following code shows how you would call the sort function on a vector <code>v</code>.
</p>

<pre>
sort(v.begin(), v.end());
</pre>

<p>
If the above line fails to compile,
you may need to include the <em>algorithm</em> header as follows.
</p>

<pre>
#include &lt;algorithm>
</pre>

<p>
Run <em>ex3fast.cpp</em> and notice how quickly it terminates.
</p>

